/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useCnwContext, CnwContext, queryKeyFn } from "./cnwContext";
import { deepMerge } from "./cnwUtils";
import type * as Fetcher from "./cnwFetcher";
import { cnwFetch } from "./cnwFetcher";
import type * as Schemas from "./cnwSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type AppControllerHealthError = Fetcher.ErrorWrapper<undefined>;

export type AppControllerHealthVariables = CnwContext["fetcherOptions"];

export const fetchAppControllerHealth = (
  variables: AppControllerHealthVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<undefined, AppControllerHealthError, undefined, {}, {}, {}>({
    url: "/api/health",
    method: "get",
    ...variables,
    signal,
  });

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/health",
      operationId: "appControllerHealth",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAppControllerHealth(variables, signal),
  };
}

export const useSuspenseAppControllerHealth = <TData = undefined>(
  variables: AppControllerHealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerHealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    AppControllerHealthError,
    TData
  >({
    ...appControllerHealthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAppControllerHealth = <TData = undefined>(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerHealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<undefined, AppControllerHealthError, TData>({
    ...appControllerHealthQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AuthControllerLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLoginResponse = {
  accessToken?: string;
  refreshToken?: string;
};

export type AuthControllerLoginVariables = {
  body: Schemas.LoginDto;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerLogin = (
  variables: AuthControllerLoginVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerLoginResponse,
    AuthControllerLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/api/auth/login", method: "post", ...variables, signal });

export const useAuthControllerLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerLoginResponse,
      AuthControllerLoginError,
      AuthControllerLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerLoginResponse,
    AuthControllerLoginError,
    AuthControllerLoginVariables
  >({
    mutationFn: (variables: AuthControllerLoginVariables) =>
      fetchAuthControllerLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRegisterResponse = {
  accessToken?: string;
  refreshToken?: string;
};

export type AuthControllerRegisterVariables = {
  body: Schemas.RegisterDto;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerRegister = (
  variables: AuthControllerRegisterVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerRegisterResponse,
    AuthControllerRegisterError,
    Schemas.RegisterDto,
    {},
    {},
    {}
  >({ url: "/api/auth/register", method: "post", ...variables, signal });

export const useAuthControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRegisterResponse,
      AuthControllerRegisterError,
      AuthControllerRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerRegisterResponse,
    AuthControllerRegisterError,
    AuthControllerRegisterVariables
  >({
    mutationFn: (variables: AuthControllerRegisterVariables) =>
      fetchAuthControllerRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRefreshTokenError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRefreshTokenResponse = {
  accessToken?: string;
  refreshToken?: string;
};

export type AuthControllerRefreshTokenVariables = {
  body: Schemas.RefreshTokenDto;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerRefreshToken = (
  variables: AuthControllerRefreshTokenVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerRefreshTokenResponse,
    AuthControllerRefreshTokenError,
    Schemas.RefreshTokenDto,
    {},
    {},
    {}
  >({ url: "/api/auth/refresh-token", method: "post", ...variables, signal });

export const useAuthControllerRefreshToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRefreshTokenResponse,
      AuthControllerRefreshTokenError,
      AuthControllerRefreshTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerRefreshTokenResponse,
    AuthControllerRefreshTokenError,
    AuthControllerRefreshTokenVariables
  >({
    mutationFn: (variables: AuthControllerRefreshTokenVariables) =>
      fetchAuthControllerRefreshToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerLogoutError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLogoutVariables = {
  body: Schemas.RefreshTokenDto;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerLogout = (
  variables: AuthControllerLogoutVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    undefined,
    AuthControllerLogoutError,
    Schemas.RefreshTokenDto,
    {},
    {},
    {}
  >({ url: "/api/auth/logout", method: "post", ...variables, signal });

export const useAuthControllerLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerLogoutError,
      AuthControllerLogoutVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerLogoutError,
    AuthControllerLogoutVariables
  >({
    mutationFn: (variables: AuthControllerLogoutVariables) =>
      fetchAuthControllerLogout(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerCheckValidTokenHeaders = {
  authorization: string;
};

export type AuthControllerCheckValidTokenError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerCheckValidTokenResponse = {
  /**
   * @example true
   */
  isValid?: boolean;
};

export type AuthControllerCheckValidTokenVariables = {
  headers: AuthControllerCheckValidTokenHeaders;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerCheckValidToken = (
  variables: AuthControllerCheckValidTokenVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerCheckValidTokenResponse,
    AuthControllerCheckValidTokenError,
    undefined,
    AuthControllerCheckValidTokenHeaders,
    {},
    {}
  >({
    url: "/api/auth/check-valid-token",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthControllerCheckValidToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerCheckValidTokenResponse,
      AuthControllerCheckValidTokenError,
      AuthControllerCheckValidTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerCheckValidTokenResponse,
    AuthControllerCheckValidTokenError,
    AuthControllerCheckValidTokenVariables
  >({
    mutationFn: (variables: AuthControllerCheckValidTokenVariables) =>
      fetchAuthControllerCheckValidToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRevokeDevicePathParams = {
  /**
   * ID của thiết bị cần thu hồi
   */
  id: string;
};

export type AuthControllerRevokeDeviceError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRevokeDeviceResponse = {
  id?: string;
  name?: string;
  userId?: string;
  /**
   * @format date-time
   */
  lastActive?: string;
  /**
   * @example false
   */
  isActive?: boolean;
  ipAddress?: string | null;
  location?: string | null;
  /**
   * @format date-time
   */
  createdAt?: string;
  /**
   * @format date-time
   */
  updatedAt?: string;
};

export type AuthControllerRevokeDeviceVariables = {
  pathParams: AuthControllerRevokeDevicePathParams;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerRevokeDevice = (
  variables: AuthControllerRevokeDeviceVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerRevokeDeviceResponse,
    AuthControllerRevokeDeviceError,
    undefined,
    {},
    {},
    AuthControllerRevokeDevicePathParams
  >({ url: "/api/auth/devices/{id}", method: "delete", ...variables, signal });

export const useAuthControllerRevokeDevice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRevokeDeviceResponse,
      AuthControllerRevokeDeviceError,
      AuthControllerRevokeDeviceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerRevokeDeviceResponse,
    AuthControllerRevokeDeviceError,
    AuthControllerRevokeDeviceVariables
  >({
    mutationFn: (variables: AuthControllerRevokeDeviceVariables) =>
      fetchAuthControllerRevokeDevice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerDeleteDevicePathParams = {
  /**
   * ID của thiết bị cần xóa
   */
  id: string;
};

export type AuthControllerDeleteDeviceError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerDeleteDeviceResponse = {
  id?: string;
  name?: string;
  userId?: string;
  /**
   * @format date-time
   */
  lastActive?: string | null;
  isActive?: boolean;
  ipAddress?: string | null;
  location?: string | null;
  /**
   * @format date-time
   */
  createdAt?: string;
  /**
   * @format date-time
   */
  updatedAt?: string;
};

export type AuthControllerDeleteDeviceVariables = {
  pathParams: AuthControllerDeleteDevicePathParams;
} & CnwContext["fetcherOptions"];

export const fetchAuthControllerDeleteDevice = (
  variables: AuthControllerDeleteDeviceVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    AuthControllerDeleteDeviceResponse,
    AuthControllerDeleteDeviceError,
    undefined,
    {},
    {},
    AuthControllerDeleteDevicePathParams
  >({
    url: "/api/auth/devices/{id}/permanent",
    method: "delete",
    ...variables,
    signal,
  });

export const useAuthControllerDeleteDevice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerDeleteDeviceResponse,
      AuthControllerDeleteDeviceError,
      AuthControllerDeleteDeviceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    AuthControllerDeleteDeviceResponse,
    AuthControllerDeleteDeviceError,
    AuthControllerDeleteDeviceVariables
  >({
    mutationFn: (variables: AuthControllerDeleteDeviceVariables) =>
      fetchAuthControllerDeleteDevice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UsersControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type UsersControllerFindOneVariables = CnwContext["fetcherOptions"];

export const fetchUsersControllerFindOne = (
  variables: UsersControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<undefined, UsersControllerFindOneError, undefined, {}, {}, {}>({
    url: "/api/users/me",
    method: "get",
    ...variables,
    signal,
  });

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/me",
      operationId: "usersControllerFindOne",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUsersControllerFindOne(variables, signal),
  };
}

export const useSuspenseUsersControllerFindOne = <TData = undefined>(
  variables: UsersControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindOneError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UsersControllerFindOneError,
    TData
  >({
    ...usersControllerFindOneQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUsersControllerFindOne = <TData = undefined>(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindOneError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<undefined, UsersControllerFindOneError, TData>({
    ...usersControllerFindOneQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UsersControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type UsersControllerFindAllVariables = CnwContext["fetcherOptions"];

export const fetchUsersControllerFindAll = (
  variables: UsersControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<undefined, UsersControllerFindAllError, undefined, {}, {}, {}>({
    url: "/api/users/all",
    method: "get",
    ...variables,
    signal,
  });

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/all",
      operationId: "usersControllerFindAll",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUsersControllerFindAll(variables, signal),
  };
}

export const useSuspenseUsersControllerFindAll = <TData = undefined>(
  variables: UsersControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindAllError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UsersControllerFindAllError,
    TData
  >({
    ...usersControllerFindAllQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUsersControllerFindAll = <TData = undefined>(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindAllError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<undefined, UsersControllerFindAllError, TData>({
    ...usersControllerFindAllQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MinioControllerCreateUploadUrlError =
  Fetcher.ErrorWrapper<undefined>;

export type MinioControllerCreateUploadUrlVariables = {
  body: Schemas.UploadURLDto;
} & CnwContext["fetcherOptions"];

export const fetchMinioControllerCreateUploadUrl = (
  variables: MinioControllerCreateUploadUrlVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    Schemas.UrlDto,
    MinioControllerCreateUploadUrlError,
    Schemas.UploadURLDto,
    {},
    {},
    {}
  >({
    url: "/api/minio/create-upload-url",
    method: "post",
    ...variables,
    signal,
  });

export const useMinioControllerCreateUploadUrl = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UrlDto,
      MinioControllerCreateUploadUrlError,
      MinioControllerCreateUploadUrlVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useCnwContext();
  return reactQuery.useMutation<
    Schemas.UrlDto,
    MinioControllerCreateUploadUrlError,
    MinioControllerCreateUploadUrlVariables
  >({
    mutationFn: (variables: MinioControllerCreateUploadUrlVariables) =>
      fetchMinioControllerCreateUploadUrl(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MinioControllerFindAllQueryParams = {
  /**
   * Đường dẫn thư mục (prefix)
   *
   * @example disasters/123e4567-e89b-12d3-a456-426614174000/
   */
  path?: string;
  /**
   * Bắt đầu sau object nào
   *
   * @example disasters/123e4567-e89b-12d3-a456-426614174000/image.jpg
   */
  startAfter?: string;
  /**
   * Số lượng tối đa object trả về
   *
   * @default 100
   * @example 50
   */
  limit?: number;
};

export type MinioControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type MinioControllerFindAllResponse = Schemas.BucketItemDto[];

export type MinioControllerFindAllVariables = {
  queryParams?: MinioControllerFindAllQueryParams;
} & CnwContext["fetcherOptions"];

export const fetchMinioControllerFindAll = (
  variables: MinioControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    MinioControllerFindAllResponse,
    MinioControllerFindAllError,
    undefined,
    {},
    MinioControllerFindAllQueryParams,
    {}
  >({ url: "/api/minio", method: "get", ...variables, signal });

export function minioControllerFindAllQuery(
  variables: MinioControllerFindAllVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MinioControllerFindAllResponse>;
};

export function minioControllerFindAllQuery(
  variables: MinioControllerFindAllVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MinioControllerFindAllResponse>)
    | reactQuery.SkipToken;
};

export function minioControllerFindAllQuery(
  variables: MinioControllerFindAllVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/minio",
      operationId: "minioControllerFindAll",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMinioControllerFindAll(variables, signal),
  };
}

export const useSuspenseMinioControllerFindAll = <
  TData = MinioControllerFindAllResponse,
>(
  variables: MinioControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MinioControllerFindAllResponse,
      MinioControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    MinioControllerFindAllResponse,
    MinioControllerFindAllError,
    TData
  >({
    ...minioControllerFindAllQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMinioControllerFindAll = <
  TData = MinioControllerFindAllResponse,
>(
  variables: MinioControllerFindAllVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MinioControllerFindAllResponse,
      MinioControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<
    MinioControllerFindAllResponse,
    MinioControllerFindAllError,
    TData
  >({
    ...minioControllerFindAllQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MinioControllerPresignedGetObjectQueryParams = {
  /**
   * Tên object cần lấy URL download
   */
  objectName: string;
};

export type MinioControllerPresignedGetObjectError =
  Fetcher.ErrorWrapper<undefined>;

export type MinioControllerPresignedGetObjectVariables = {
  queryParams: MinioControllerPresignedGetObjectQueryParams;
} & CnwContext["fetcherOptions"];

export const fetchMinioControllerPresignedGetObject = (
  variables: MinioControllerPresignedGetObjectVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    Schemas.UrlDto,
    MinioControllerPresignedGetObjectError,
    undefined,
    {},
    MinioControllerPresignedGetObjectQueryParams,
    {}
  >({
    url: "/api/minio/create-download-url",
    method: "get",
    ...variables,
    signal,
  });

export function minioControllerPresignedGetObjectQuery(
  variables: MinioControllerPresignedGetObjectVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UrlDto>;
};

export function minioControllerPresignedGetObjectQuery(
  variables: MinioControllerPresignedGetObjectVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UrlDto>)
    | reactQuery.SkipToken;
};

export function minioControllerPresignedGetObjectQuery(
  variables: MinioControllerPresignedGetObjectVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/minio/create-download-url",
      operationId: "minioControllerPresignedGetObject",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMinioControllerPresignedGetObject(variables, signal),
  };
}

export const useSuspenseMinioControllerPresignedGetObject = <
  TData = Schemas.UrlDto,
>(
  variables: MinioControllerPresignedGetObjectVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UrlDto,
      MinioControllerPresignedGetObjectError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UrlDto,
    MinioControllerPresignedGetObjectError,
    TData
  >({
    ...minioControllerPresignedGetObjectQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useMinioControllerPresignedGetObject = <TData = Schemas.UrlDto>(
  variables: MinioControllerPresignedGetObjectVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UrlDto,
      MinioControllerPresignedGetObjectError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<
    Schemas.UrlDto,
    MinioControllerPresignedGetObjectError,
    TData
  >({
    ...minioControllerPresignedGetObjectQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MinioControllerGetPublicUrlQueryParams = {
  /**
   * Tên object cần lấy URL công khai
   */
  objectName: string;
};

export type MinioControllerGetPublicUrlError = Fetcher.ErrorWrapper<undefined>;

export type MinioControllerGetPublicUrlVariables = {
  queryParams: MinioControllerGetPublicUrlQueryParams;
} & CnwContext["fetcherOptions"];

export const fetchMinioControllerGetPublicUrl = (
  variables: MinioControllerGetPublicUrlVariables,
  signal?: AbortSignal,
) =>
  cnwFetch<
    Schemas.UrlDto,
    MinioControllerGetPublicUrlError,
    undefined,
    {},
    MinioControllerGetPublicUrlQueryParams,
    {}
  >({ url: "/api/minio/public-url", method: "get", ...variables, signal });

export function minioControllerGetPublicUrlQuery(
  variables: MinioControllerGetPublicUrlVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UrlDto>;
};

export function minioControllerGetPublicUrlQuery(
  variables: MinioControllerGetPublicUrlVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UrlDto>)
    | reactQuery.SkipToken;
};

export function minioControllerGetPublicUrlQuery(
  variables: MinioControllerGetPublicUrlVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/minio/public-url",
      operationId: "minioControllerGetPublicUrl",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMinioControllerGetPublicUrl(variables, signal),
  };
}

export const useSuspenseMinioControllerGetPublicUrl = <TData = Schemas.UrlDto>(
  variables: MinioControllerGetPublicUrlVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UrlDto,
      MinioControllerGetPublicUrlError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UrlDto,
    MinioControllerGetPublicUrlError,
    TData
  >({
    ...minioControllerGetPublicUrlQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMinioControllerGetPublicUrl = <TData = Schemas.UrlDto>(
  variables: MinioControllerGetPublicUrlVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UrlDto,
      MinioControllerGetPublicUrlError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useCnwContext(options);
  return reactQuery.useQuery<
    Schemas.UrlDto,
    MinioControllerGetPublicUrlError,
    TData
  >({
    ...minioControllerGetPublicUrlQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/health";
      operationId: "appControllerHealth";
      variables: AppControllerHealthVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/me";
      operationId: "usersControllerFindOne";
      variables: UsersControllerFindOneVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/all";
      operationId: "usersControllerFindAll";
      variables: UsersControllerFindAllVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/minio";
      operationId: "minioControllerFindAll";
      variables: MinioControllerFindAllVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/minio/create-download-url";
      operationId: "minioControllerPresignedGetObject";
      variables:
        | MinioControllerPresignedGetObjectVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/api/minio/public-url";
      operationId: "minioControllerGetPublicUrl";
      variables: MinioControllerGetPublicUrlVariables | reactQuery.SkipToken;
    };

/******************************************************************************
 * This file was generated by ZenStack CLI.
 ******************************************************************************/

/* eslint-disable */

import type { Prisma, RefreshToken } from "@prisma/client";
import type {
  UseMutationOptions,
  UseQueryOptions,
  UseInfiniteQueryOptions,
  InfiniteData,
} from "@tanstack/react-query";
import { getHooksContext } from "@zenstackhq/tanstack-query/runtime-v5/react";
import {
  useModelQuery,
  useInfiniteModelQuery,
  useModelMutation,
} from "@zenstackhq/tanstack-query/runtime-v5/react";
import type {
  PickEnumerable,
  CheckSelect,
  QueryError,
  ExtraQueryOptions,
  ExtraMutationOptions,
} from "@zenstackhq/tanstack-query/runtime-v5";
import type { PolicyCrudKind } from "@zenstackhq/runtime";
import metadata from "./__model_meta";
type DefaultError = QueryError;
import {
  useSuspenseModelQuery,
  useSuspenseInfiniteModelQuery,
} from "@zenstackhq/tanstack-query/runtime-v5/react";
import type {
  UseSuspenseQueryOptions,
  UseSuspenseInfiniteQueryOptions,
} from "@tanstack/react-query";

export function useCreateRefreshToken(
  options?: Omit<
    UseMutationOptions<
      RefreshToken | undefined,
      DefaultError,
      Prisma.RefreshTokenCreateArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenCreateArgs,
    DefaultError,
    RefreshToken,
    true
  >(
    "RefreshToken",
    "POST",
    `${endpoint}/refreshToken/create`,
    metadata,
    options,
    fetch,
    true,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenCreateArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenCreateArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenCreateArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
        | undefined;
    },
  };
  return mutation;
}

export function useCreateManyRefreshToken(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.RefreshTokenCreateManyArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenCreateManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    "RefreshToken",
    "POST",
    `${endpoint}/refreshToken/createMany`,
    metadata,
    options,
    fetch,
    false,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenCreateManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenCreateManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenCreateManyArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload;
    },
  };
  return mutation;
}

export function useFindManyRefreshToken<
  TArgs extends Prisma.RefreshTokenFindManyArgs,
  TQueryFnData = Array<
    Prisma.RefreshTokenGetPayload<TArgs> & { $optimistic?: boolean }
  >,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindManyArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findMany`,
    args,
    options,
    fetch,
  );
}

export function useInfiniteFindManyRefreshToken<
  TArgs extends Prisma.RefreshTokenFindManyArgs,
  TQueryFnData = Array<Prisma.RefreshTokenGetPayload<TArgs>>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindManyArgs>,
  options?: Omit<
    UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>,
    "queryKey" | "initialPageParam"
  >,
) {
  options = options ?? { getNextPageParam: () => null };
  const { endpoint, fetch } = getHooksContext();
  return useInfiniteModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findMany`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseFindManyRefreshToken<
  TArgs extends Prisma.RefreshTokenFindManyArgs,
  TQueryFnData = Array<
    Prisma.RefreshTokenGetPayload<TArgs> & { $optimistic?: boolean }
  >,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindManyArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findMany`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseInfiniteFindManyRefreshToken<
  TArgs extends Prisma.RefreshTokenFindManyArgs,
  TQueryFnData = Array<Prisma.RefreshTokenGetPayload<TArgs>>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindManyArgs>,
  options?: Omit<
    UseSuspenseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>,
    "queryKey" | "initialPageParam"
  >,
) {
  options = options ?? { getNextPageParam: () => null };
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseInfiniteModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findMany`,
    args,
    options,
    fetch,
  );
}

export function useFindUniqueRefreshToken<
  TArgs extends Prisma.RefreshTokenFindUniqueArgs,
  TQueryFnData = Prisma.RefreshTokenGetPayload<TArgs> & {
    $optimistic?: boolean;
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindUniqueArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findUnique`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseFindUniqueRefreshToken<
  TArgs extends Prisma.RefreshTokenFindUniqueArgs,
  TQueryFnData = Prisma.RefreshTokenGetPayload<TArgs> & {
    $optimistic?: boolean;
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindUniqueArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findUnique`,
    args,
    options,
    fetch,
  );
}

export function useFindFirstRefreshToken<
  TArgs extends Prisma.RefreshTokenFindFirstArgs,
  TQueryFnData = Prisma.RefreshTokenGetPayload<TArgs> & {
    $optimistic?: boolean;
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindFirstArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findFirst`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseFindFirstRefreshToken<
  TArgs extends Prisma.RefreshTokenFindFirstArgs,
  TQueryFnData = Prisma.RefreshTokenGetPayload<TArgs> & {
    $optimistic?: boolean;
  },
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenFindFirstArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/findFirst`,
    args,
    options,
    fetch,
  );
}

export function useUpdateRefreshToken(
  options?: Omit<
    UseMutationOptions<
      RefreshToken | undefined,
      DefaultError,
      Prisma.RefreshTokenUpdateArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenUpdateArgs,
    DefaultError,
    RefreshToken,
    true
  >(
    "RefreshToken",
    "PUT",
    `${endpoint}/refreshToken/update`,
    metadata,
    options,
    fetch,
    true,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenUpdateArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenUpdateArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenUpdateArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
        | undefined;
    },
  };
  return mutation;
}

export function useUpdateManyRefreshToken(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.RefreshTokenUpdateManyArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenUpdateManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    "RefreshToken",
    "PUT",
    `${endpoint}/refreshToken/updateMany`,
    metadata,
    options,
    fetch,
    false,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenUpdateManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenUpdateManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenUpdateManyArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload;
    },
  };
  return mutation;
}

export function useUpsertRefreshToken(
  options?: Omit<
    UseMutationOptions<
      RefreshToken | undefined,
      DefaultError,
      Prisma.RefreshTokenUpsertArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenUpsertArgs,
    DefaultError,
    RefreshToken,
    true
  >(
    "RefreshToken",
    "POST",
    `${endpoint}/refreshToken/upsert`,
    metadata,
    options,
    fetch,
    true,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenUpsertArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenUpsertArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenUpsertArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
        | undefined;
    },
  };
  return mutation;
}

export function useDeleteRefreshToken(
  options?: Omit<
    UseMutationOptions<
      RefreshToken | undefined,
      DefaultError,
      Prisma.RefreshTokenDeleteArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenDeleteArgs,
    DefaultError,
    RefreshToken,
    true
  >(
    "RefreshToken",
    "DELETE",
    `${endpoint}/refreshToken/delete`,
    metadata,
    options,
    fetch,
    true,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenDeleteArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenDeleteArgs>,
      options?: Omit<
        UseMutationOptions<
          | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
          | undefined,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenDeleteArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(args, options as any)) as
        | CheckSelect<T, RefreshToken, Prisma.RefreshTokenGetPayload<T>>
        | undefined;
    },
  };
  return mutation;
}

export function useDeleteManyRefreshToken(
  options?: Omit<
    UseMutationOptions<
      Prisma.BatchPayload,
      DefaultError,
      Prisma.RefreshTokenDeleteManyArgs
    > &
      ExtraMutationOptions,
    "mutationFn"
  >,
) {
  const { endpoint, fetch } = getHooksContext();
  const _mutation = useModelMutation<
    Prisma.RefreshTokenDeleteManyArgs,
    DefaultError,
    Prisma.BatchPayload,
    false
  >(
    "RefreshToken",
    "DELETE",
    `${endpoint}/refreshToken/deleteMany`,
    metadata,
    options,
    fetch,
    false,
  );
  const mutation = {
    ..._mutation,
    mutateAsync: async <T extends Prisma.RefreshTokenDeleteManyArgs>(
      args: Prisma.SelectSubset<T, Prisma.RefreshTokenDeleteManyArgs>,
      options?: Omit<
        UseMutationOptions<
          Prisma.BatchPayload,
          DefaultError,
          Prisma.SelectSubset<T, Prisma.RefreshTokenDeleteManyArgs>
        > &
          ExtraMutationOptions,
        "mutationFn"
      >,
    ) => {
      return (await _mutation.mutateAsync(
        args,
        options as any,
      )) as Prisma.BatchPayload;
    },
  };
  return mutation;
}

export function useAggregateRefreshToken<
  TArgs extends Prisma.RefreshTokenAggregateArgs,
  TQueryFnData = Prisma.GetRefreshTokenAggregateType<TArgs>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenAggregateArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/aggregate`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseAggregateRefreshToken<
  TArgs extends Prisma.RefreshTokenAggregateArgs,
  TQueryFnData = Prisma.GetRefreshTokenAggregateType<TArgs>,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenAggregateArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/aggregate`,
    args,
    options,
    fetch,
  );
}

export function useGroupByRefreshToken<
  TArgs extends Prisma.RefreshTokenGroupByArgs,
  HasSelectOrTake extends Prisma.Or<
    Prisma.Extends<"skip", Prisma.Keys<TArgs>>,
    Prisma.Extends<"take", Prisma.Keys<TArgs>>
  >,
  OrderByArg extends Prisma.True extends HasSelectOrTake
    ? { orderBy: Prisma.RefreshTokenGroupByArgs["orderBy"] }
    : { orderBy?: Prisma.RefreshTokenGroupByArgs["orderBy"] },
  OrderFields extends Prisma.ExcludeUnderscoreKeys<
    Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs["orderBy"]>>
  >,
  ByFields extends Prisma.MaybeTupleToUnion<TArgs["by"]>,
  ByValid extends Prisma.Has<ByFields, OrderFields>,
  HavingFields extends Prisma.GetHavingFields<TArgs["having"]>,
  HavingValid extends Prisma.Has<ByFields, HavingFields>,
  ByEmpty extends TArgs["by"] extends never[] ? Prisma.True : Prisma.False,
  InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`,
                ];
        }[HavingFields]
      : "take" extends Prisma.Keys<TArgs>
        ? "orderBy" extends Prisma.Keys<TArgs>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Prisma.Keys<TArgs>
          ? "orderBy" extends Prisma.Keys<TArgs>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "skip", you also need to provide "orderBy"'
          : ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields],
  TQueryFnData = {} extends InputErrors
    ? Array<
        PickEnumerable<Prisma.RefreshTokenGroupByOutputType, TArgs["by"]> & {
          [P in keyof TArgs &
            keyof Prisma.RefreshTokenGroupByOutputType]: P extends "_count"
            ? TArgs[P] extends boolean
              ? number
              : Prisma.GetScalarType<
                  TArgs[P],
                  Prisma.RefreshTokenGroupByOutputType[P]
                >
            : Prisma.GetScalarType<
                TArgs[P],
                Prisma.RefreshTokenGroupByOutputType[P]
              >;
        }
      >
    : InputErrors,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<
    TArgs,
    Prisma.SubsetIntersection<
      TArgs,
      Prisma.RefreshTokenGroupByArgs,
      OrderByArg
    > &
      InputErrors
  >,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/groupBy`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseGroupByRefreshToken<
  TArgs extends Prisma.RefreshTokenGroupByArgs,
  HasSelectOrTake extends Prisma.Or<
    Prisma.Extends<"skip", Prisma.Keys<TArgs>>,
    Prisma.Extends<"take", Prisma.Keys<TArgs>>
  >,
  OrderByArg extends Prisma.True extends HasSelectOrTake
    ? { orderBy: Prisma.RefreshTokenGroupByArgs["orderBy"] }
    : { orderBy?: Prisma.RefreshTokenGroupByArgs["orderBy"] },
  OrderFields extends Prisma.ExcludeUnderscoreKeys<
    Prisma.Keys<Prisma.MaybeTupleToUnion<TArgs["orderBy"]>>
  >,
  ByFields extends Prisma.MaybeTupleToUnion<TArgs["by"]>,
  ByValid extends Prisma.Has<ByFields, OrderFields>,
  HavingFields extends Prisma.GetHavingFields<TArgs["having"]>,
  HavingValid extends Prisma.Has<ByFields, HavingFields>,
  ByEmpty extends TArgs["by"] extends never[] ? Prisma.True : Prisma.False,
  InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` in "having" needs to be provided in "by"`,
                ];
        }[HavingFields]
      : "take" extends Prisma.Keys<TArgs>
        ? "orderBy" extends Prisma.Keys<TArgs>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Prisma.Keys<TArgs>
          ? "orderBy" extends Prisma.Keys<TArgs>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "skip", you also need to provide "orderBy"'
          : ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields],
  TQueryFnData = {} extends InputErrors
    ? Array<
        PickEnumerable<Prisma.RefreshTokenGroupByOutputType, TArgs["by"]> & {
          [P in keyof TArgs &
            keyof Prisma.RefreshTokenGroupByOutputType]: P extends "_count"
            ? TArgs[P] extends boolean
              ? number
              : Prisma.GetScalarType<
                  TArgs[P],
                  Prisma.RefreshTokenGroupByOutputType[P]
                >
            : Prisma.GetScalarType<
                TArgs[P],
                Prisma.RefreshTokenGroupByOutputType[P]
              >;
        }
      >
    : InputErrors,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args: Prisma.SelectSubset<
    TArgs,
    Prisma.SubsetIntersection<
      TArgs,
      Prisma.RefreshTokenGroupByArgs,
      OrderByArg
    > &
      InputErrors
  >,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/groupBy`,
    args,
    options,
    fetch,
  );
}

export function useCountRefreshToken<
  TArgs extends Prisma.RefreshTokenCountArgs,
  TQueryFnData = TArgs extends { select: any }
    ? TArgs["select"] extends true
      ? number
      : Prisma.GetScalarType<
          TArgs["select"],
          Prisma.RefreshTokenCountAggregateOutputType
        >
    : number,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenCountArgs>,
  options?: Omit<UseQueryOptions<TQueryFnData, TError, TData>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/count`,
    args,
    options,
    fetch,
  );
}

export function useSuspenseCountRefreshToken<
  TArgs extends Prisma.RefreshTokenCountArgs,
  TQueryFnData = TArgs extends { select: any }
    ? TArgs["select"] extends true
      ? number
      : Prisma.GetScalarType<
          TArgs["select"],
          Prisma.RefreshTokenCountAggregateOutputType
        >
    : number,
  TData = TQueryFnData,
  TError = DefaultError,
>(
  args?: Prisma.SelectSubset<TArgs, Prisma.RefreshTokenCountArgs>,
  options?: Omit<
    UseSuspenseQueryOptions<TQueryFnData, TError, TData>,
    "queryKey"
  > &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useSuspenseModelQuery<TQueryFnData, TData, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/count`,
    args,
    options,
    fetch,
  );
}

export function useCheckRefreshToken<TError = DefaultError>(
  args: {
    operation: PolicyCrudKind;
    where?: {
      id?: string;
      description?: string;
      token?: string;
      userId?: string;
      revoked?: boolean;
      deviceId?: string;
    };
  },
  options?: Omit<UseQueryOptions<boolean, TError, boolean>, "queryKey"> &
    ExtraQueryOptions,
) {
  const { endpoint, fetch } = getHooksContext();
  return useModelQuery<boolean, boolean, TError>(
    "RefreshToken",
    `${endpoint}/refreshToken/check`,
    args,
    options,
    fetch,
  );
}
